<<<<<<< HEAD
fg_tmc.t("trial", "trial.tree", 2020, "SS", 20, 20, 2.5, stand_mean_dbh = 20, stand_top_ht = 20, stand_mean_ht = 20, predominant_species = NA, full_output = 0, elev_ht = 20)
fg_tmc("trial", "trial.tree", 2020, "SS", 20, 20, 2.5, stand_mean_dbh = 20, stand_top_ht = 20, stand_mean_ht = 20, predominant_species = species, full_output = 0)
#' Wrapper for the single-tree (turning moment coefficient) method.
#' @title ForestGALES - Single-tree (TMC) method.
#' @param stand_id Stand identifier. Essential.
#' @param tree_id Tree identifier. Essential.
#' @param date Date of wind damage risk assessment. Optional (but useful!).
#' @param species Tree species under investigation. Essential.
#' @param tree_ht Individual tree height (m). Essential.
#' @param dbh Diameter of the stem at breast height, i.e. 1.3m above the ground (cm). Essential.
#' @param spacing_current Current mean spacing of trees in the stand (m). Essential.
#' @param predominant_species Predominant species in the stand.
#' @param stand_mean_ht Arithmetic mean height of the trees in the stand (m). Essential.
#' @param stand_mean_dbh Mean dbh of all trees in the stand (cm) - arithmetic average. Dbh is diameter at breast height, measured at 1.3m above the ground. Essential.
#' @param stand_top_ht Height of the dominant tree(s) in the stand (m). Essential.
#' @param full_output Switch between full and basic outputs.
#' @param weib_a Scale parameter of the Weibull distribution for local wind speeds.
#' @param weib_k Shape parameter of the Weibull distribution for local wind speeds.
#' @param ci Competition Index (\code{BAL}, \code{Hegyi}, \code{None}) used.
#' @param ci_value Value of \code{ci}.
#' @param elev_ht The height at which the elevated critical wind speed is calculated (m). For the TMC method, this defaults to 1.05 * stand top height
#' @param cr_width Width of the tree crown (m).
#' @param cr_depth Length of the tree crown (m).
#' @param stand_cr_width Width of the crown of the mean tree in the stand (m).
#' @param stand_cr_depth Length of the crown of the mean tree in the stand (m).
#' @param soil_group Soil group identifier (1 = freely draining mineral soils; 2 = gleyed mineral soils; 3 = peaty mineral soils; 4 = deep peats).
#' @param rooting Rooting depth class (1 = Shallow, 2 = Deep, 3 = Medium).
#' @param dist_edge Distance of tree from the upwind edge (m).
#' @param gap_size Length of the upwind gap (m).
#' @param spacing_before Mean spacing of trees in the stand before any thinning (m).
#' @param years_since_thin Number of years since most recent thinning.
#' @param moe Modulus of Elasticity of green wood (MPa). Advanced Input.
#' @param mor Modulus of Rupture of green wood (MPa). Advanced Input.
#' @param fknot Knot factor (dimensionless). Advanced Input.
#' @param stem_vol Individual tree stem volume (m3). Advanced Input.
#' @param crown_vol Volume of the crown of individual trees (m3). Advanced Input.
#' @param stem_density Density of green wood of the stem (kg m-3). Advanced Input.
#' @param crown_density Density of the crown of individual trees (kg m-3). Advanced Input.
#' @param c_reg Regression coefficient of uprooting moment against stem weight (N m kg-1). Advanced Input.
#' @param c_drag C parameter of the drag coefficient formula (dimensionless). Advanced Input.
#' @param n_drag N parameter of the drag coefficient formula (dimensionless). Advanced Input.
#' @param drag_upper_limit Maximum wind speed used during the experiments from which \code{n_drag} and \code{c_drag} were derived (m*s-1). Advanced Input.
#' @param snow_depth Depth of layer of snow on tree crown (cm). Advanced Input.
#' @param snow_density Density of snow (kg m-3). Advanced Input.
#' @param ro Air density (kg m-3). Advanced Input.
#' @param x Spatial coordinate.
#' @param y Spatial coordinate.
#' @param z Spatial coordinate.
#' @param dams DAMS (Detailed Aspect Method of Scoring) value to describe the local wind climate (for UK conditions only).
#' @return If \code{full_output} = 1, a comprehensive list including: stand and tree id's; for breakage and overturning, the critical wind speeds (m s-1) at
#'  canopy top height and anemometer's height; zero plane displacement height (m), canopy surface roughness (m); canopy drag; ratio of critical wind speed at
#'  canopy top over friction velocity (uh / u*); drag per unit ground area; the turning moment coefficient; the turning moment ratio; the deflection loading
#'  factor; the critical breaking moment and the critical overturning moment; the combined effect of edge and gap on the applied bending moment; the probabilities
#'  of damage; the mode of damage; a summary of the inputs. If \code{full_output} = 0, a much shorter list including: stand id and tree id's; the critical
#'  wind speeds of breakage and overturning, and the associated probabilities.
fg_tmc.t <- function(stand_id, tree_id, date, species, tree_ht, dbh, spacing_current, predominant_species = NA, stand_mean_ht, stand_mean_dbh, stand_top_ht,
full_output = 1, weib_a = NA, weib_k = NA, ci = NA, ci_value = NA, elev_ht = NA, cr_width = NA, cr_depth = NA, stand_cr_width = NA, stand_cr_depth = NA,
soil_group = NA, rooting = NA, dist_edge = NA, gap_size = NA, spacing_before = NA, years_since_thin = NA, moe = NA, mor = NA, fknot = NA,
stem_vol = NA,crown_vol = NA, stem_density = NA, crown_density = NA, c_reg = NA, c_drag = NA, n_drag = NA, drag_upper_limit = NA,
snow_depth = NA, snow_density = NA, ro = NA, x = NA, y = NA, z = NA, dams = NA) { #
#1. Check essentials (stand_id, tree_id, species, tree_ht, dbh, spacing_current, stand_mean_dbh + stand_mean_ht&stand_top_ht):
essentials <- c(stand_id, tree_id, species, tree_ht, dbh, spacing_current, stand_mean_dbh, stand_top_ht)
stopifnot(!anyNA(essentials))
#stopifnot(!(is.na(stand_mean_ht) && is.na(stand_top_ht)))
#if(is.na(stand_mean_ht) & is.na(stand_top_ht)) stop("Essentials missing")
#ifelse(is.na(stand_mean_ht), ifelse(is.na(stand_top_ht), stop("Essentials missing")))
spacing_current <- round(spacing_current, 1)
#2. An "equivalent mean stand height" needs to be calculated from stand top height using a generic stand top height to equivalent mean stand height conversion.
#This equivalent mean stand height represents the level in the stand responsible for most of the momentum absorption. For this reason, stand top height is an essential input.
#In fact, stand top height is largely independent of the understorey. This conversion, based on average slope and intercept from the species in ForestGALES, is as below:
equivalent_mean_ht <- eq_mean_ht_fun(stand_top_ht)
#OLD_2. If stand_top_ht is not provided, calculate it from stand_mean_ht, and viceversa. This requires knowledge of the predominant_species, which if not specified is equal to species
#stand_mean_ht is used in the calculations of z0 and zpd, while stand_top_ht# in the elevate function
predominant_species <- ifelse(is.na(predominant_species), species, predominant_species) #still required to assign species-specific parameters
#param0_standHt <- species_parameters[species, "param0_height"] #get(paste0("param0_height_", predominant_species))
#param1_standHt <- species_parameters[species, "param1_height"] #get(paste0("param1_height_", predominant_species))
#stand_mean_ht <- ifelse(is.na(stand_mean_ht), param0_standHt + param1_standHt * stand_top_ht, stand_mean_ht)
#stand_mean_ht <- ifelse(is.na(stand_mean_ht), top_ht_to_mean_ht(param0_standHt, param1_standHt, stand_top_ht), stand_mean_ht)
#stand_top_ht <- ifelse(is.na(stand_top_ht), (stand_mean_ht - param0_standHt) / param1_standHt, stand_top_ht)
#stand_top_ht <- ifelse(is.na(stand_top_ht), mean_ht_to_top_ht(param0_standHt, param1_standHt, stand_mean_ht), stand_top_ht)
#3. Check desirables (cr_width, cr_depth, stand_cr_width, stand_cr_depth, soil_group, rooting, gap_size, dist_edge, status) and initialise 'default_warning':
desirables <- c(cr_width, cr_depth, stand_cr_width, stand_cr_depth, soil_group, rooting, gap_size, dist_edge)
default_warning <- ifelse(anyNA(desirables), "defw", NA) #"Warning: some inputs were set to default values"
#Single tree first:
param0_cr_width <- species_parameters[species, "param0_cr_width"] #get(paste0("param0_crWidth_", species))
param1_cr_width <- species_parameters[species, "param1_cr_width"] #get(paste0("param1_crWidth_", species))
#cr_width <- ifelse(is.na(cr_width), param0_cr_width + param1_cr_width * dbh, cr_width)
cr_width <- ifelse(is.na(cr_width), canopy_width_fun(param0_cr_width, param1_cr_width, dbh), cr_width)
#cr_width <- ifelse (cr_width > 2 * spacing_current, 2 * spacing_current, cr_width)
#cr_width <- ifelse(cr_width > tree_ht, tree_ht, cr_width)
cr_width <- round(cr_width, 2)
param0_cr_depth <- species_parameters[species, "param0_cr_depth"] #get(paste0("param0_cr_depth_", species))
param1_cr_depth <- species_parameters[species, "param1_cr_depth"] #get(paste0("param1_cr_depth_", species))
#cr_depth <- ifelse(is.na(cr_depth), param0_cr_depth + param1_cr_depth * tree_ht, cr_depth)
cr_depth <- ifelse(is.na(cr_depth), canopy_depth_fun(param0_cr_depth, param1_cr_depth, tree_ht), cr_depth)
cr_depth <- ifelse(cr_depth > tree_ht, tree_ht, cr_depth)
#cr_depth <- ifelse(cr_depth < 1, 1, cr_depth)
cr_depth <- round(cr_depth, 2)
#stand "equivalent mean tree":
param0_stand_cr_width <- species_parameters[predominant_species, "param0_cr_width"] #get(paste0("param0_crWidth_", predominant_species))
param1_stand_cr_width <- species_parameters[predominant_species, "param1_cr_width"] #get(paste0("param1_crWidth_", predominant_species))
#stand_cr_width <- ifelse(is.na(stand_cr_width), param0_stand_cr_width + param1_stand_cr_width * stand_mean_dbh, stand_cr_width)
stand_cr_width <- ifelse(is.na(stand_cr_width), canopy_width_fun(param0_stand_cr_width, param1_stand_cr_width, stand_mean_dbh), stand_cr_width)
#stand_cr_width <- ifelse (stand_cr_width > 2 * spacing_current, 2 * spacing_current, stand_cr_width)
#stand_cr_width <- ifelse(stand_cr_width > stand_mean_ht, stand_mean_ht, stand_cr_width)
stand_cr_width <- round(stand_cr_width, 2)
param0_stand_cr_depth <- species_parameters[predominant_species, "param0_cr_depth"] #get(paste0("param0_crDepth_", predominant_species))
param1_stand_cr_depth <- species_parameters[predominant_species, "param1_cr_depth"] #get(paste0("param1_crDepth_", predominant_species))
#stand_cr_depth <- ifelse(is.na(stand_cr_depth), param0_stand_cr_depth + param1_stand_cr_depth * stand_mean_ht, stand_cr_depth)
stand_cr_depth <- ifelse(is.na(stand_cr_depth), canopy_depth_fun(param0_stand_cr_depth, param1_stand_cr_depth, equivalent_mean_ht), stand_cr_depth)
stand_cr_depth <- ifelse(stand_cr_depth > equivalent_mean_ht, equivalent_mean_ht, stand_cr_depth)
#stand_cr_depth <- ifelse(stand_cr_depth < 1, 1, stand_cr_depth)
stand_cr_depth <- round(stand_cr_depth, 2)
soil_group <- ifelse(is.na(soil_group), 1, soil_group) #defaults to 1: Freely draining mineral soils - Soil Group A
rooting <- ifelse(is.na(rooting), 3, rooting) #defaults to 3 to choose average of c_reg from combined shallow and deep rooting data
dist_edge <- ifelse(is.na(dist_edge), fgr_constants$tree_heights_inside_forest*equivalent_mean_ht, dist_edge)
gap_size <- ifelse(is.na(gap_size), 0, gap_size)
#4. Check competition variables:
#status <- ifelse(is.na(status), "co", status)
ci <- ifelse(is.na(ci), "none", ci)
ci_value <- ifelse(is.na(ci_value), NA, ci_value)
#5. Check variables required for modelling effect of thinning:
spacing_before <- round(ifelse(is.na(spacing_before), spacing_current, spacing_before), 1)
years_since_thin <- ifelse(is.na(years_since_thin), 5, years_since_thin)
years_since_thin <- ifelse(years_since_thin < 0, 0, years_since_thin)
years_since_thin <- ifelse(years_since_thin > 5, 5, years_since_thin)
#6. Check Advanced Inputs (elev_ht, moe, mor, fknot, stem_vol, stem_density, crown_vol, crown_density, c_reg, c_drag, n_drag, drag_upper_limit, snow_depth, snow_density, ro). Calculate volume of stem, crown, snow
elev_ht <- ifelse(is.na(elev_ht), 1.05*stand_top_ht, elev_ht) #Default height to calculate elevated u_crit is mean_ht
moe <- ifelse(is.na(moe), species_parameters[species, "moe"], moe) #get(paste0("moe_", species)), moe)
mor <- ifelse(is.na(mor), species_parameters[species, "mor"], mor) #get(paste0("mor_", species)), mor)
stem_density <- ifelse(is.na(stem_density), species_parameters[species, "stem_density"], stem_density) #get(paste0("stem_density_", species)), stem_density)
crown_density <- ifelse(is.na(crown_density), species_parameters[species, "canopy_density"], crown_density) #get(paste0("canopy_density_", species)), crown_density)
fknot <- ifelse(is.na(fknot), species_parameters[species, "fknot"], fknot) #get(paste0("fknot_", species)), fknot)
#c_drag, n_drag, and drag_upper_limit are used in the calculations of the aerodynamic variables (drag, zpd, z0, lambdaCapital, gammaSolved). They are thus stand-level properties and therefore
#require that the parameters required for their calculation belong to the predominant species in the stand.
c_drag <- ifelse(is.na(c_drag), species_parameters[predominant_species, "c_drag"], c_drag) #get(paste0("c_drag_", predominant_species)), c_drag)
n_drag <- ifelse(is.na(n_drag), species_parameters[predominant_species, "n_drag"], n_drag) #get(paste0("n_drag_", predominant_species)), n_drag)
drag_upper_limit <- ifelse(is.na(drag_upper_limit), species_parameters[predominant_species, "drag_upper_limit"], drag_upper_limit) #get(paste0("drag_upper_limit_", predominant_species)), drag_upper_limit)
rb <- species_parameters[predominant_species, "rb"] #get(paste0("RB_", species)) #Root Bending Term, from Neild and Wood
snow_depth <- ifelse(is.na(snow_depth), 0, snow_depth)
snow_density <- ifelse(is.na(snow_density), fgr_constants$snow_density_default, snow_density)
ro <- ifelse(is.na(ro), fgr_constants$ro_default, ro)
#Overturning Moment Multipliers (c_reg, n m/kg):
#omm_dataframe <- get(paste0("omm_dataframe_", species))
c_reg <- ifelse(is.na(c_reg), species_parameters[species, paste0("c_reg_soil_", soil_group, "_rd_", rooting)], c_reg) #get(paste0("c_reg_soil_", soil_group, "_rd_", rooting)), c_reg) #omm_dataframe[rooting, soil_group], c_reg) #'rooting' and 'soil_group' as rows and columns indices
stem_vol <- ifelse(is.na(stem_vol), stem_vol_fun(species, dbh, tree_ht), stem_vol)
crown_vol <- ifelse(is.na(crown_vol), 1/3 * pi * cr_depth * (cr_width/2)^2, crown_vol)
snow_vol <- ifelse(is.na(snow_depth), NA, pi * snow_depth * (cr_width/2)^2)
#7. Calculate stem weight and extract max stem weight to check confidence of overturning predictions. Calculate crown weight and snow weight
stem_weight <- stem_vol * stem_density
#msw_dataframe <- get(paste0("msw_dataframe_", species))
msw <- species_parameters[species, paste0("msw_soil_", soil_group, "_rd_", rooting)] #msw_dataframe[rooting, soil_group]
max_stem_weight_warning <- ifelse(stem_weight > msw, "msw", NA) #"Warning: the weight of the stem exceeds the data used to calculate the resistance to overturning"
crown_weight <- crown_vol * crown_density
snow_weight <- ifelse(is.na(snow_vol), NA, snow_vol * snow_density)
#8. Calculate Critical Wind Speeds and CWS-related outputs: (uh_b, uh_o, tmc, tmr_simple, dlf_calc, breaking_moment, overturning_moment, edge_gap_factor).
#Outputs are given as lists, from which they are then extracted.
#BREAKAGE:
uh_b_results <- uh_breakage_tmc(tree_ht, dbh, cr_depth, cr_width, spacing_current, spacing_before, years_since_thin, dist_edge, gap_size, moe, mor, fknot,
stem_vol, stem_density, crown_density, snow_depth, snow_density, ci, ci_value, n_drag, c_drag, drag_upper_limit, equivalent_mean_ht, stand_cr_depth, stand_cr_width) #output list contains (uh_b, tmc, tmr_full, dlf_calc, breaking_moment, edge_gap_factor)
#  uh_b_results_tmr_simple <- uh_breakage_tmc_tmr_simple(tree_ht, dbh, cr_depth, cr_width, spacing_current, spacing_before, years_since_thin, dist_edge, gap_size, equivalent_mean_ht, moe, mor, fknot,
#                                  stem_vol, stem_density, crown_density, snow_depth, snow_density, ci, ci_value) #output list contains (uh_b, tmc, tmr_simple, dlf_calc, breaking_moment, edge_gap_factor)
#OVERTURNING:
uh_o_results <- uh_overturning_tmc(tree_ht, dbh, cr_depth, cr_width, spacing_current, spacing_before, years_since_thin, dist_edge, gap_size, moe, c_reg,
stem_vol, stem_density, crown_density, snow_depth, snow_density, ci, ci_value, n_drag, c_drag, drag_upper_limit, equivalent_mean_ht, stand_cr_depth, stand_cr_width) #output list contains (uh_o, tmc, tmr_full, dlf_calc, overturning_moment, edge_gap_factor)
#  uh_o_results <- uh_overturning_tmc_tmr_simple(tree_ht, dbh, cr_depth, cr_width, spacing_current, spacing_before, years_since_thin, dist_edge, gap_size, equivalent_mean_ht, moe, c_reg,
#                                  stem_vol, stem_density, crown_density, snow_depth, snow_density, ci, ci_value) #output list contains (uh_o, tmc, tmr_simple, dlf_calc, overturning_moment, edge_gap_factor)
#Extracting values:
breaking_moment <- as.numeric(uh_b_results)[5]
overturning_moment <- as.numeric(uh_o_results)[5]
dlf_calc <- as.numeric(uh_b_results)[4] #Deflection Loading Factor
edge_gap_factor <- as.numeric(uh_b_results)[6]
tmc <- as.numeric(uh_b_results)[2]
tmr_full <- as.numeric(uh_b_results)[3]
dlf_used <- as.numeric(uh_b_results)[7]
#tmr_simple <- as.numeric(uh_b_results)[3]
#CWS:
uh_b <- as.numeric(uh_b_results)[1] #critical wind speed for breakage at canopy top
uh_o <- as.numeric(uh_o_results)[1] #critical wind speed for overturning at canopy top
#9. Calculate zpd and z0 for the elevate function. Also calculate other streamlining parameters (drag, gammaSolved, LambdaCapital).
#These outputs all depend on the CWS so they are given for breakage and overturning:
zpd_b <- zpd_fun(stand_cr_width, stand_cr_depth, spacing_current, uh_b, n_drag, c_drag, drag_upper_limit, equivalent_mean_ht) #Zero plane displacement. This for breakage
z0_b <- z0_fun(stand_cr_width, stand_cr_depth, spacing_current, uh_b, n_drag, c_drag, drag_upper_limit, equivalent_mean_ht) #Canopy roughness. This for breakage
lambdacapital_b <- lambdacapital_fun(stand_cr_width, stand_cr_depth, spacing_current, uh_b, n_drag, c_drag, drag_upper_limit) #Drag per unit ground area. This for breakage
gammasolved_b <- gammasolved_fun(stand_cr_width, stand_cr_depth, spacing_current, uh_b, n_drag, c_drag, drag_upper_limit) #Ratio of critical wind speed at canopy top over friction velocity (uh / u*). This for breakage
canopybreadth_b <- canopy_breadth_fun(stand_cr_width, uh_b, n_drag, c_drag, drag_upper_limit) #breadth of streamlined canopy for breakage
drag_b <- drag_fun(uh_b, n_drag, c_drag, drag_upper_limit) #Drag (porosity) of crown. This for breakage
zpd_o <- zpd_fun(stand_cr_width, stand_cr_depth, spacing_current, uh_o, n_drag, c_drag, drag_upper_limit, equivalent_mean_ht) #Zero plane displacement. This for overturning
z0_o <- z0_fun(stand_cr_width, stand_cr_depth, spacing_current, uh_o, n_drag, c_drag, drag_upper_limit, equivalent_mean_ht) #Canopy roughness. This for overturning
gammasolved_o <- gammasolved_fun(stand_cr_width, stand_cr_depth, spacing_current, uh_o, n_drag, c_drag, drag_upper_limit) #Ratio of critical wind speed at canopy top over friction velocity (uh / u*). This for overturning
lambdacapital_o <- lambdacapital_fun(stand_cr_width, stand_cr_depth, spacing_current, uh_o, n_drag, c_drag, drag_upper_limit) #Drag per unit ground area. This for overturning
canopybreadth_o <- canopy_breadth_fun(stand_cr_width, uh_o, n_drag, c_drag, drag_upper_limit) #breadth of streamlined canopy for breakage
drag_o <- drag_fun(uh_o, n_drag, c_drag, drag_upper_limit) #Drag (porosity) of crown. This for overturning
#10. Elevate uh to anemometer height (10m + zpd)
u10_b <- elevate(uh_b, z0_b, zpd_b, elev_ht) #This for breakage
u10_o <- elevate(uh_o, z0_o, zpd_o, elev_ht) #This for overturning
#11. Select CWS and mode of damage
u_damage <- ifelse(uh_b < uh_o, uh_b, uh_o)
u10_damage <- ifelse(u10_b < u10_o, u10_b, u10_o)
mode_of_damage <- ifelse(u10_b < u10_o, "Breakage", "Overturning")
#12. Check Wind Climate variables: (dams, weib_a, weib_k)
weib_k <- ifelse(is.na(weib_k), 1.85, weib_k)
weib_a <- ifelse(is.na(dams) & is.na(weib_a), weib_a, ifelse(is.na(dams), weib_a, ifelse(is.na(weib_a), fgr_constants$dams_to_weibull_a1 + fgr_constants$dams_to_weibull_a2*dams, weib_a)))
#13. Calculate Probability of (breakage, overturning, damage) and associated return periods
prob_b <- ifelse(is.na(weib_a), NA, annual_exceedance_prob(u10_b, weib_a, weib_k))
prob_o <- ifelse(is.na(weib_a), NA, annual_exceedance_prob(u10_o, weib_a, weib_k))
prob_damage <- ifelse(is.na(weib_a), NA, annual_exceedance_prob(u10_damage, weib_a, weib_k))
#14. Outputs in long and short forms:
#add stems per hectare (sph):
sph_before <- round(10000 / (spacing_before^2), 0)
sph_current <- round(10000 / (spacing_current^2), 0)
fgr_warnings <- paste0(default_warning, "_", max_stem_weight_warning)
fg_tmc_out_full <- list(stand_id = stand_id, tree_id = tree_id, date = date, species = species, u10_b = u10_b, uh_b = uh_b, prob_b = prob_b, zpd_b = zpd_b, z0_b = z0_b,
drag_b = drag_b, gammasolved_b = gammasolved_b, lambdacapital_b = lambdacapital_b, canopybreadth_b = canopybreadth_b,
breaking_moment = breaking_moment, u10_o = u10_o, uh_o = uh_o, prob_o = prob_o, zpd_o = zpd_o, z0_o = z0_o, drag_o = drag_o,
gammasolved_o = gammasolved_o,lambdacapital_o = lambdacapital_o, canopybreadth_o = canopybreadth_o, overturning_moment = overturning_moment, c_reg = c_reg,
mode_of_damage = mode_of_damage, u10_damage = u10_damage, u_damage = u_damage, prob_damage = prob_damage,
tmc = tmc, tmr_full = tmr_full, ci = ci, ci_value = ci_value,
tree_ht = tree_ht, dbh = dbh, cr_width = cr_width, cr_depth = cr_depth, dlf_calc = dlf_calc, dlf_used = dlf_used, stem_vol = stem_vol,
stem_density = stem_density, stem_weight = stem_weight, crown_vol = crown_vol, crown_density = crown_density,
crown_weight = crown_weight, snow_depth = snow_depth, snow_density = snow_density, snow_weight = snow_weight,
predominant_species = predominant_species, stand_mean_ht = stand_mean_ht, stand_top_ht = stand_top_ht, equivalent_mean_ht = equivalent_mean_ht,
stand_mean_dbh = stand_mean_dbh, stand_cr_width = stand_cr_width, stand_cr_depth = stand_cr_depth,
c_drag = c_drag, n_drag = n_drag, drag_upper_limit = drag_upper_limit, spacing_current = spacing_current,
spacing_before = spacing_before, sph_current = sph_current, sph_before = sph_before, years_since_thin = years_since_thin, soil_group = soil_group, rooting = rooting,
weib_a = weib_a, weib_k = weib_k, dist_edge = dist_edge, gap_size = gap_size, edge_gap_factor = edge_gap_factor, elev_ht = elev_ht,
moe = moe, mor = mor, fknot = fknot, ro = ro, x = x, y = y, z = z, dams = dams, Warnings = fgr_warnings)
fg_tmc_out_short <-   list(stand_id = stand_id, tree_id = tree_id, date = date, species = species, u10_damage = u10_damage, mode_of_damage = mode_of_damage,
u10_b = u10_b, u10_o = u10_o, prob_damage = prob_damage, prob_b = prob_b, prob_o = prob_o, Warnings = fgr_warnings)
if(full_output == 1) {
fg_tmc_out <- fg_tmc_out_full
} else fg_tmc_out <- fg_tmc_out_short
return(fg_tmc_out)
}
fg_tmc.t("trial", "trial.tree", 2020, "SS", 20, 20, 2.5, stand_mean_dbh = 20, stand_top_ht = 20, stand_mean_ht = 20, full_output = 0, elev_ht = 20)
#' Wrapper for the single-tree (turning moment coefficient) method.
#' @title ForestGALES - Single-tree (TMC) method.
#' @param stand_id Stand identifier. Essential.
#' @param tree_id Tree identifier. Essential.
#' @param date Date of wind damage risk assessment. Optional (but useful!).
#' @param species Tree species under investigation. Essential.
#' @param tree_ht Individual tree height (m). Essential.
#' @param dbh Diameter of the stem at breast height, i.e. 1.3m above the ground (cm). Essential.
#' @param spacing_current Current mean spacing of trees in the stand (m). Essential.
#' @param predominant_species Predominant species in the stand.
#' @param stand_mean_ht Arithmetic mean height of the trees in the stand (m). Essential.
#' @param stand_mean_dbh Mean dbh of all trees in the stand (cm) - arithmetic average. Dbh is diameter at breast height, measured at 1.3m above the ground. Essential.
#' @param stand_top_ht Height of the dominant tree(s) in the stand (m). Essential.
#' @param full_output Switch between full and basic outputs.
#' @param weib_a Scale parameter of the Weibull distribution for local wind speeds.
#' @param weib_k Shape parameter of the Weibull distribution for local wind speeds.
#' @param ci Competition Index (\code{BAL}, \code{Hegyi}, \code{None}) used.
#' @param ci_value Value of \code{ci}.
#' @param elev_ht The height at which the elevated critical wind speed is calculated (m). For the TMC method, this defaults to 1.05 * stand top height
#' @param cr_width Width of the tree crown (m).
#' @param cr_depth Length of the tree crown (m).
#' @param stand_cr_width Width of the crown of the mean tree in the stand (m).
#' @param stand_cr_depth Length of the crown of the mean tree in the stand (m).
#' @param soil_group Soil group identifier (1 = freely draining mineral soils; 2 = gleyed mineral soils; 3 = peaty mineral soils; 4 = deep peats).
#' @param rooting Rooting depth class (1 = Shallow, 2 = Deep, 3 = Medium).
#' @param dist_edge Distance of tree from the upwind edge (m).
#' @param gap_size Length of the upwind gap (m).
#' @param spacing_before Mean spacing of trees in the stand before any thinning (m).
#' @param years_since_thin Number of years since most recent thinning.
#' @param moe Modulus of Elasticity of green wood (MPa). Advanced Input.
#' @param mor Modulus of Rupture of green wood (MPa). Advanced Input.
#' @param fknot Knot factor (dimensionless). Advanced Input.
#' @param stem_vol Individual tree stem volume (m3). Advanced Input.
#' @param crown_vol Volume of the crown of individual trees (m3). Advanced Input.
#' @param stem_density Density of green wood of the stem (kg m-3). Advanced Input.
#' @param crown_density Density of the crown of individual trees (kg m-3). Advanced Input.
#' @param c_reg Regression coefficient of uprooting moment against stem weight (N m kg-1). Advanced Input.
#' @param c_drag C parameter of the drag coefficient formula (dimensionless). Advanced Input.
#' @param n_drag N parameter of the drag coefficient formula (dimensionless). Advanced Input.
#' @param drag_upper_limit Maximum wind speed used during the experiments from which \code{n_drag} and \code{c_drag} were derived (m*s-1). Advanced Input.
#' @param snow_depth Depth of layer of snow on tree crown (cm). Advanced Input.
#' @param snow_density Density of snow (kg m-3). Advanced Input.
#' @param ro Air density (kg m-3). Advanced Input.
#' @param x Spatial coordinate.
#' @param y Spatial coordinate.
#' @param z Spatial coordinate.
#' @param dams DAMS (Detailed Aspect Method of Scoring) value to describe the local wind climate (for UK conditions only).
#' @return If \code{full_output} = 1, a comprehensive list including: stand and tree id's; for breakage and overturning, the critical wind speeds (m s-1) at
#'  canopy top height and anemometer's height; zero plane displacement height (m), canopy surface roughness (m); canopy drag; ratio of critical wind speed at
#'  canopy top over friction velocity (uh / u*); drag per unit ground area; the turning moment coefficient; the turning moment ratio; the deflection loading
#'  factor; the critical breaking moment and the critical overturning moment; the combined effect of edge and gap on the applied bending moment; the probabilities
#'  of damage; the mode of damage; a summary of the inputs. If \code{full_output} = 0, a much shorter list including: stand id and tree id's; the critical
#'  wind speeds of breakage and overturning, and the associated probabilities.
fg_tmc.t <- function(stand_id, tree_id, date, species, tree_ht, dbh, spacing_current, predominant_species = species, stand_mean_ht, stand_mean_dbh, stand_top_ht,
full_output = 1, weib_a = NA, weib_k = NA, ci = NA, ci_value = NA, elev_ht = NA, cr_width = NA, cr_depth = NA, stand_cr_width = NA, stand_cr_depth = NA,
soil_group = NA, rooting = NA, dist_edge = NA, gap_size = NA, spacing_before = NA, years_since_thin = NA, moe = NA, mor = NA, fknot = NA,
stem_vol = NA,crown_vol = NA, stem_density = NA, crown_density = NA, c_reg = NA, c_drag = NA, n_drag = NA, drag_upper_limit = NA,
snow_depth = NA, snow_density = NA, ro = NA, x = NA, y = NA, z = NA, dams = NA) { #
#1. Check essentials (stand_id, tree_id, species, tree_ht, dbh, spacing_current, stand_mean_dbh + stand_mean_ht&stand_top_ht):
essentials <- c(stand_id, tree_id, species, tree_ht, dbh, spacing_current, stand_mean_dbh, stand_top_ht)
stopifnot(!anyNA(essentials))
#stopifnot(!(is.na(stand_mean_ht) && is.na(stand_top_ht)))
#if(is.na(stand_mean_ht) & is.na(stand_top_ht)) stop("Essentials missing")
#ifelse(is.na(stand_mean_ht), ifelse(is.na(stand_top_ht), stop("Essentials missing")))
spacing_current <- round(spacing_current, 1)
#2. An "equivalent mean stand height" needs to be calculated from stand top height using a generic stand top height to equivalent mean stand height conversion.
#This equivalent mean stand height represents the level in the stand responsible for most of the momentum absorption. For this reason, stand top height is an essential input.
#In fact, stand top height is largely independent of the understorey. This conversion, based on average slope and intercept from the species in ForestGALES, is as below:
equivalent_mean_ht <- eq_mean_ht_fun(stand_top_ht)
#OLD_2. If stand_top_ht is not provided, calculate it from stand_mean_ht, and viceversa. This requires knowledge of the predominant_species, which if not specified is equal to species
#stand_mean_ht is used in the calculations of z0 and zpd, while stand_top_ht# in the elevate function
predominant_species <- ifelse(is.na(predominant_species), species, predominant_species) #still required to assign species-specific parameters
#param0_standHt <- species_parameters[species, "param0_height"] #get(paste0("param0_height_", predominant_species))
#param1_standHt <- species_parameters[species, "param1_height"] #get(paste0("param1_height_", predominant_species))
#stand_mean_ht <- ifelse(is.na(stand_mean_ht), param0_standHt + param1_standHt * stand_top_ht, stand_mean_ht)
#stand_mean_ht <- ifelse(is.na(stand_mean_ht), top_ht_to_mean_ht(param0_standHt, param1_standHt, stand_top_ht), stand_mean_ht)
#stand_top_ht <- ifelse(is.na(stand_top_ht), (stand_mean_ht - param0_standHt) / param1_standHt, stand_top_ht)
#stand_top_ht <- ifelse(is.na(stand_top_ht), mean_ht_to_top_ht(param0_standHt, param1_standHt, stand_mean_ht), stand_top_ht)
#3. Check desirables (cr_width, cr_depth, stand_cr_width, stand_cr_depth, soil_group, rooting, gap_size, dist_edge, status) and initialise 'default_warning':
desirables <- c(cr_width, cr_depth, stand_cr_width, stand_cr_depth, soil_group, rooting, gap_size, dist_edge)
default_warning <- ifelse(anyNA(desirables), "defw", NA) #"Warning: some inputs were set to default values"
#Single tree first:
param0_cr_width <- species_parameters[species, "param0_cr_width"] #get(paste0("param0_crWidth_", species))
param1_cr_width <- species_parameters[species, "param1_cr_width"] #get(paste0("param1_crWidth_", species))
#cr_width <- ifelse(is.na(cr_width), param0_cr_width + param1_cr_width * dbh, cr_width)
cr_width <- ifelse(is.na(cr_width), canopy_width_fun(param0_cr_width, param1_cr_width, dbh), cr_width)
#cr_width <- ifelse (cr_width > 2 * spacing_current, 2 * spacing_current, cr_width)
#cr_width <- ifelse(cr_width > tree_ht, tree_ht, cr_width)
cr_width <- round(cr_width, 2)
param0_cr_depth <- species_parameters[species, "param0_cr_depth"] #get(paste0("param0_cr_depth_", species))
param1_cr_depth <- species_parameters[species, "param1_cr_depth"] #get(paste0("param1_cr_depth_", species))
#cr_depth <- ifelse(is.na(cr_depth), param0_cr_depth + param1_cr_depth * tree_ht, cr_depth)
cr_depth <- ifelse(is.na(cr_depth), canopy_depth_fun(param0_cr_depth, param1_cr_depth, tree_ht), cr_depth)
cr_depth <- ifelse(cr_depth > tree_ht, tree_ht, cr_depth)
#cr_depth <- ifelse(cr_depth < 1, 1, cr_depth)
cr_depth <- round(cr_depth, 2)
#stand "equivalent mean tree":
param0_stand_cr_width <- species_parameters[predominant_species, "param0_cr_width"] #get(paste0("param0_crWidth_", predominant_species))
param1_stand_cr_width <- species_parameters[predominant_species, "param1_cr_width"] #get(paste0("param1_crWidth_", predominant_species))
#stand_cr_width <- ifelse(is.na(stand_cr_width), param0_stand_cr_width + param1_stand_cr_width * stand_mean_dbh, stand_cr_width)
stand_cr_width <- ifelse(is.na(stand_cr_width), canopy_width_fun(param0_stand_cr_width, param1_stand_cr_width, stand_mean_dbh), stand_cr_width)
#stand_cr_width <- ifelse (stand_cr_width > 2 * spacing_current, 2 * spacing_current, stand_cr_width)
#stand_cr_width <- ifelse(stand_cr_width > stand_mean_ht, stand_mean_ht, stand_cr_width)
stand_cr_width <- round(stand_cr_width, 2)
param0_stand_cr_depth <- species_parameters[predominant_species, "param0_cr_depth"] #get(paste0("param0_crDepth_", predominant_species))
param1_stand_cr_depth <- species_parameters[predominant_species, "param1_cr_depth"] #get(paste0("param1_crDepth_", predominant_species))
#stand_cr_depth <- ifelse(is.na(stand_cr_depth), param0_stand_cr_depth + param1_stand_cr_depth * stand_mean_ht, stand_cr_depth)
stand_cr_depth <- ifelse(is.na(stand_cr_depth), canopy_depth_fun(param0_stand_cr_depth, param1_stand_cr_depth, equivalent_mean_ht), stand_cr_depth)
stand_cr_depth <- ifelse(stand_cr_depth > equivalent_mean_ht, equivalent_mean_ht, stand_cr_depth)
#stand_cr_depth <- ifelse(stand_cr_depth < 1, 1, stand_cr_depth)
stand_cr_depth <- round(stand_cr_depth, 2)
soil_group <- ifelse(is.na(soil_group), 1, soil_group) #defaults to 1: Freely draining mineral soils - Soil Group A
rooting <- ifelse(is.na(rooting), 3, rooting) #defaults to 3 to choose average of c_reg from combined shallow and deep rooting data
dist_edge <- ifelse(is.na(dist_edge), fgr_constants$tree_heights_inside_forest*equivalent_mean_ht, dist_edge)
gap_size <- ifelse(is.na(gap_size), 0, gap_size)
#4. Check competition variables:
#status <- ifelse(is.na(status), "co", status)
ci <- ifelse(is.na(ci), "none", ci)
ci_value <- ifelse(is.na(ci_value), NA, ci_value)
#5. Check variables required for modelling effect of thinning:
spacing_before <- round(ifelse(is.na(spacing_before), spacing_current, spacing_before), 1)
years_since_thin <- ifelse(is.na(years_since_thin), 5, years_since_thin)
years_since_thin <- ifelse(years_since_thin < 0, 0, years_since_thin)
years_since_thin <- ifelse(years_since_thin > 5, 5, years_since_thin)
#6. Check Advanced Inputs (elev_ht, moe, mor, fknot, stem_vol, stem_density, crown_vol, crown_density, c_reg, c_drag, n_drag, drag_upper_limit, snow_depth, snow_density, ro). Calculate volume of stem, crown, snow
elev_ht <- ifelse(is.na(elev_ht), 1.05*stand_top_ht, elev_ht) #Default height to calculate elevated u_crit is mean_ht
moe <- ifelse(is.na(moe), species_parameters[species, "moe"], moe) #get(paste0("moe_", species)), moe)
mor <- ifelse(is.na(mor), species_parameters[species, "mor"], mor) #get(paste0("mor_", species)), mor)
stem_density <- ifelse(is.na(stem_density), species_parameters[species, "stem_density"], stem_density) #get(paste0("stem_density_", species)), stem_density)
crown_density <- ifelse(is.na(crown_density), species_parameters[species, "canopy_density"], crown_density) #get(paste0("canopy_density_", species)), crown_density)
fknot <- ifelse(is.na(fknot), species_parameters[species, "fknot"], fknot) #get(paste0("fknot_", species)), fknot)
#c_drag, n_drag, and drag_upper_limit are used in the calculations of the aerodynamic variables (drag, zpd, z0, lambdaCapital, gammaSolved). They are thus stand-level properties and therefore
#require that the parameters required for their calculation belong to the predominant species in the stand.
c_drag <- ifelse(is.na(c_drag), species_parameters[predominant_species, "c_drag"], c_drag) #get(paste0("c_drag_", predominant_species)), c_drag)
n_drag <- ifelse(is.na(n_drag), species_parameters[predominant_species, "n_drag"], n_drag) #get(paste0("n_drag_", predominant_species)), n_drag)
drag_upper_limit <- ifelse(is.na(drag_upper_limit), species_parameters[predominant_species, "drag_upper_limit"], drag_upper_limit) #get(paste0("drag_upper_limit_", predominant_species)), drag_upper_limit)
rb <- species_parameters[predominant_species, "rb"] #get(paste0("RB_", species)) #Root Bending Term, from Neild and Wood
snow_depth <- ifelse(is.na(snow_depth), 0, snow_depth)
snow_density <- ifelse(is.na(snow_density), fgr_constants$snow_density_default, snow_density)
ro <- ifelse(is.na(ro), fgr_constants$ro_default, ro)
#Overturning Moment Multipliers (c_reg, n m/kg):
#omm_dataframe <- get(paste0("omm_dataframe_", species))
c_reg <- ifelse(is.na(c_reg), species_parameters[species, paste0("c_reg_soil_", soil_group, "_rd_", rooting)], c_reg) #get(paste0("c_reg_soil_", soil_group, "_rd_", rooting)), c_reg) #omm_dataframe[rooting, soil_group], c_reg) #'rooting' and 'soil_group' as rows and columns indices
stem_vol <- ifelse(is.na(stem_vol), stem_vol_fun(species, dbh, tree_ht), stem_vol)
crown_vol <- ifelse(is.na(crown_vol), 1/3 * pi * cr_depth * (cr_width/2)^2, crown_vol)
snow_vol <- ifelse(is.na(snow_depth), NA, pi * snow_depth * (cr_width/2)^2)
#7. Calculate stem weight and extract max stem weight to check confidence of overturning predictions. Calculate crown weight and snow weight
stem_weight <- stem_vol * stem_density
#msw_dataframe <- get(paste0("msw_dataframe_", species))
msw <- species_parameters[species, paste0("msw_soil_", soil_group, "_rd_", rooting)] #msw_dataframe[rooting, soil_group]
max_stem_weight_warning <- ifelse(stem_weight > msw, "msw", NA) #"Warning: the weight of the stem exceeds the data used to calculate the resistance to overturning"
crown_weight <- crown_vol * crown_density
snow_weight <- ifelse(is.na(snow_vol), NA, snow_vol * snow_density)
#8. Calculate Critical Wind Speeds and CWS-related outputs: (uh_b, uh_o, tmc, tmr_simple, dlf_calc, breaking_moment, overturning_moment, edge_gap_factor).
#Outputs are given as lists, from which they are then extracted.
#BREAKAGE:
uh_b_results <- uh_breakage_tmc(tree_ht, dbh, cr_depth, cr_width, spacing_current, spacing_before, years_since_thin, dist_edge, gap_size, moe, mor, fknot,
stem_vol, stem_density, crown_density, snow_depth, snow_density, ci, ci_value, n_drag, c_drag, drag_upper_limit, equivalent_mean_ht, stand_cr_depth, stand_cr_width) #output list contains (uh_b, tmc, tmr_full, dlf_calc, breaking_moment, edge_gap_factor)
#  uh_b_results_tmr_simple <- uh_breakage_tmc_tmr_simple(tree_ht, dbh, cr_depth, cr_width, spacing_current, spacing_before, years_since_thin, dist_edge, gap_size, equivalent_mean_ht, moe, mor, fknot,
#                                  stem_vol, stem_density, crown_density, snow_depth, snow_density, ci, ci_value) #output list contains (uh_b, tmc, tmr_simple, dlf_calc, breaking_moment, edge_gap_factor)
#OVERTURNING:
uh_o_results <- uh_overturning_tmc(tree_ht, dbh, cr_depth, cr_width, spacing_current, spacing_before, years_since_thin, dist_edge, gap_size, moe, c_reg,
stem_vol, stem_density, crown_density, snow_depth, snow_density, ci, ci_value, n_drag, c_drag, drag_upper_limit, equivalent_mean_ht, stand_cr_depth, stand_cr_width) #output list contains (uh_o, tmc, tmr_full, dlf_calc, overturning_moment, edge_gap_factor)
#  uh_o_results <- uh_overturning_tmc_tmr_simple(tree_ht, dbh, cr_depth, cr_width, spacing_current, spacing_before, years_since_thin, dist_edge, gap_size, equivalent_mean_ht, moe, c_reg,
#                                  stem_vol, stem_density, crown_density, snow_depth, snow_density, ci, ci_value) #output list contains (uh_o, tmc, tmr_simple, dlf_calc, overturning_moment, edge_gap_factor)
#Extracting values:
breaking_moment <- as.numeric(uh_b_results)[5]
overturning_moment <- as.numeric(uh_o_results)[5]
dlf_calc <- as.numeric(uh_b_results)[4] #Deflection Loading Factor
edge_gap_factor <- as.numeric(uh_b_results)[6]
tmc <- as.numeric(uh_b_results)[2]
tmr_full <- as.numeric(uh_b_results)[3]
dlf_used <- as.numeric(uh_b_results)[7]
#tmr_simple <- as.numeric(uh_b_results)[3]
#CWS:
uh_b <- as.numeric(uh_b_results)[1] #critical wind speed for breakage at canopy top
uh_o <- as.numeric(uh_o_results)[1] #critical wind speed for overturning at canopy top
#9. Calculate zpd and z0 for the elevate function. Also calculate other streamlining parameters (drag, gammaSolved, LambdaCapital).
#These outputs all depend on the CWS so they are given for breakage and overturning:
zpd_b <- zpd_fun(stand_cr_width, stand_cr_depth, spacing_current, uh_b, n_drag, c_drag, drag_upper_limit, equivalent_mean_ht) #Zero plane displacement. This for breakage
z0_b <- z0_fun(stand_cr_width, stand_cr_depth, spacing_current, uh_b, n_drag, c_drag, drag_upper_limit, equivalent_mean_ht) #Canopy roughness. This for breakage
lambdacapital_b <- lambdacapital_fun(stand_cr_width, stand_cr_depth, spacing_current, uh_b, n_drag, c_drag, drag_upper_limit) #Drag per unit ground area. This for breakage
gammasolved_b <- gammasolved_fun(stand_cr_width, stand_cr_depth, spacing_current, uh_b, n_drag, c_drag, drag_upper_limit) #Ratio of critical wind speed at canopy top over friction velocity (uh / u*). This for breakage
canopybreadth_b <- canopy_breadth_fun(stand_cr_width, uh_b, n_drag, c_drag, drag_upper_limit) #breadth of streamlined canopy for breakage
drag_b <- drag_fun(uh_b, n_drag, c_drag, drag_upper_limit) #Drag (porosity) of crown. This for breakage
zpd_o <- zpd_fun(stand_cr_width, stand_cr_depth, spacing_current, uh_o, n_drag, c_drag, drag_upper_limit, equivalent_mean_ht) #Zero plane displacement. This for overturning
z0_o <- z0_fun(stand_cr_width, stand_cr_depth, spacing_current, uh_o, n_drag, c_drag, drag_upper_limit, equivalent_mean_ht) #Canopy roughness. This for overturning
gammasolved_o <- gammasolved_fun(stand_cr_width, stand_cr_depth, spacing_current, uh_o, n_drag, c_drag, drag_upper_limit) #Ratio of critical wind speed at canopy top over friction velocity (uh / u*). This for overturning
lambdacapital_o <- lambdacapital_fun(stand_cr_width, stand_cr_depth, spacing_current, uh_o, n_drag, c_drag, drag_upper_limit) #Drag per unit ground area. This for overturning
canopybreadth_o <- canopy_breadth_fun(stand_cr_width, uh_o, n_drag, c_drag, drag_upper_limit) #breadth of streamlined canopy for breakage
drag_o <- drag_fun(uh_o, n_drag, c_drag, drag_upper_limit) #Drag (porosity) of crown. This for overturning
#10. Elevate uh to anemometer height (10m + zpd)
u10_b <- elevate(uh_b, z0_b, zpd_b, elev_ht) #This for breakage
u10_o <- elevate(uh_o, z0_o, zpd_o, elev_ht) #This for overturning
#11. Select CWS and mode of damage
u_damage <- ifelse(uh_b < uh_o, uh_b, uh_o)
u10_damage <- ifelse(u10_b < u10_o, u10_b, u10_o)
mode_of_damage <- ifelse(u10_b < u10_o, "Breakage", "Overturning")
#12. Check Wind Climate variables: (dams, weib_a, weib_k)
weib_k <- ifelse(is.na(weib_k), 1.85, weib_k)
weib_a <- ifelse(is.na(dams) & is.na(weib_a), weib_a, ifelse(is.na(dams), weib_a, ifelse(is.na(weib_a), fgr_constants$dams_to_weibull_a1 + fgr_constants$dams_to_weibull_a2*dams, weib_a)))
#13. Calculate Probability of (breakage, overturning, damage) and associated return periods
prob_b <- ifelse(is.na(weib_a), NA, annual_exceedance_prob(u10_b, weib_a, weib_k))
prob_o <- ifelse(is.na(weib_a), NA, annual_exceedance_prob(u10_o, weib_a, weib_k))
prob_damage <- ifelse(is.na(weib_a), NA, annual_exceedance_prob(u10_damage, weib_a, weib_k))
#14. Outputs in long and short forms:
#add stems per hectare (sph):
sph_before <- round(10000 / (spacing_before^2), 0)
sph_current <- round(10000 / (spacing_current^2), 0)
fgr_warnings <- paste0(default_warning, "_", max_stem_weight_warning)
fg_tmc_out_full <- list(stand_id = stand_id, tree_id = tree_id, date = date, species = species, u10_b = u10_b, uh_b = uh_b, prob_b = prob_b, zpd_b = zpd_b, z0_b = z0_b,
drag_b = drag_b, gammasolved_b = gammasolved_b, lambdacapital_b = lambdacapital_b, canopybreadth_b = canopybreadth_b,
breaking_moment = breaking_moment, u10_o = u10_o, uh_o = uh_o, prob_o = prob_o, zpd_o = zpd_o, z0_o = z0_o, drag_o = drag_o,
gammasolved_o = gammasolved_o,lambdacapital_o = lambdacapital_o, canopybreadth_o = canopybreadth_o, overturning_moment = overturning_moment, c_reg = c_reg,
mode_of_damage = mode_of_damage, u10_damage = u10_damage, u_damage = u_damage, prob_damage = prob_damage,
tmc = tmc, tmr_full = tmr_full, ci = ci, ci_value = ci_value,
tree_ht = tree_ht, dbh = dbh, cr_width = cr_width, cr_depth = cr_depth, dlf_calc = dlf_calc, dlf_used = dlf_used, stem_vol = stem_vol,
stem_density = stem_density, stem_weight = stem_weight, crown_vol = crown_vol, crown_density = crown_density,
crown_weight = crown_weight, snow_depth = snow_depth, snow_density = snow_density, snow_weight = snow_weight,
predominant_species = predominant_species, stand_mean_ht = stand_mean_ht, stand_top_ht = stand_top_ht, equivalent_mean_ht = equivalent_mean_ht,
stand_mean_dbh = stand_mean_dbh, stand_cr_width = stand_cr_width, stand_cr_depth = stand_cr_depth,
c_drag = c_drag, n_drag = n_drag, drag_upper_limit = drag_upper_limit, spacing_current = spacing_current,
spacing_before = spacing_before, sph_current = sph_current, sph_before = sph_before, years_since_thin = years_since_thin, soil_group = soil_group, rooting = rooting,
weib_a = weib_a, weib_k = weib_k, dist_edge = dist_edge, gap_size = gap_size, edge_gap_factor = edge_gap_factor, elev_ht = elev_ht,
moe = moe, mor = mor, fknot = fknot, ro = ro, x = x, y = y, z = z, dams = dams, Warnings = fgr_warnings)
fg_tmc_out_short <-   list(stand_id = stand_id, tree_id = tree_id, date = date, species = species, u10_damage = u10_damage, mode_of_damage = mode_of_damage,
u10_b = u10_b, u10_o = u10_o, prob_damage = prob_damage, prob_b = prob_b, prob_o = prob_o, Warnings = fgr_warnings)
if(full_output == 1) {
fg_tmc_out <- fg_tmc_out_full
} else fg_tmc_out <- fg_tmc_out_short
return(fg_tmc_out)
}
fg_tmc.t("trial", "trial.tree", 2020, "SS", 20, 20, 2.5, stand_mean_dbh = 20, stand_top_ht = 20, stand_mean_ht = 20, full_output = 0, elev_ht = 20)
species_parameters
view(species_parameters)
View(species_parameters)
detach("package:fgr", unload=TRUE)
load("C:/Program Files/RStudio/fgr/fgr/R/sysdata.rda")
View(species_parameters)
#data####
species_parameters <- read.csv("C:/Program Files/RStudio/fgr/ForestGALES-R scripts/species_parameters_032019.csv", header = TRUE, row.names = 1)
fgr_constants <- read.csv("C:/Program Files/RStudio/fgr/ForestGALES-R scripts/fgr_constants.csv", header = TRUE)
#user defined data
ud_species_parameters <- species_parameters
ud_fgr_constants <- fgr_constants
devtools::use_data(ud_species_parameters, ud_fgr_constants, pkg = ".", internal = FALSE, overwrite = TRUE)
?devtools::use_this
load("C:/Program Files/RStudio/fgr/fgr/data/ud_species_parameters.rda")
View(ud_fgr_constants)
View(ud_species_parameters)
rm(species_parameters)
rm(fgr_constants)
rm(ud_species_parameters)
#example of saving data:
load(file = "C:/Program Files/RStudio/fgr/fgr/data/ud_species_parameters.rda")
View(ud_fgr_constants)
View(ud_species_parameters)
#Viewe it:
View(ud_species_parameters)
ud_species_parameters(SS, stem_density)
ud_species_parameters[SS, stem_density]
ud_species_parameters["SS", "stem_density"]
ud_species_parameters["SS", "stem_density"] <- 404
ud_species_parameters["SS", "stem_density"]
#Save new version with revised value:
save(ud_species_parameters, file = "C:/Program Files/RStudio/fgr/ForestGALES-R scripts/mydata.rda")
load(file = "C:/Program Files/RStudio/fgr/ForestGALES-R scripts/mydata.rda")
rm(ud_species_parameters)
load("C:/Program Files/RStudio/fgr/fgr/data/ud_species_parameters.rda")
#Change SS Stem Density:
ud_species_parameters["SS", "stem_density"] <- 404
mydata <- ud_species_parameters
#Save new version with revised value:
save(mydata, file = "C:/Program Files/RStudio/fgr/ForestGALES-R scripts/mydata.rda")
load(file = "C:/Program Files/RStudio/fgr/ForestGALES-R scripts/mydata.rda")
mydata["SS", "stem_density"]
View(mydata)
=======
#head(df_tmc_moses_gb$treeid[df_tmc_moses_gb$stand == "Kielder~1~10"])
df_tmc_moses_gb$year <- as.factor(df_tmc_moses_gb$year)
#length(df_tmc_moses_gb$treeid[df_tmc_moses_gb$stand== "Clocaenog~1~3" & df_tmc_moses_gb$year == 2218])
#levels(df_tmc_moses_gb$year)
#Calculating spacing per site per year (using loops -bad! Use data.table library instead! see below):
#for (i in levels(df_tmc_moses_gb$stand)) { #create objects with numbers of stems per site per year
#  for (j in levels(df_tmc_moses_gb$year)) {
#    assign(paste0("stem_no_", i , "_", j), length(df_tmc_moses_gb$treeid[df_tmc_moses_gb$stand == i & df_tmc_moses_gb$year == j]))
#  }
#}
#for (i in 1:length(df_tmc_moses_gb$treeid)) { #add a column in the df_tmc_moses_gb data frame with the numbers of stems per site per year
#  df_tmc_moses_gb$stem_no[i] <- get(paste0("stem_no_", df_tmc_moses_gb$stand[i], "_", df_tmc_moses_gb$year[i]))
#}
#Calculating stand mean height per site per year. Spacing and stand top height require knowledge of plot area:
library(data.table)
df_tmc_moses_gb <- as.data.frame(setDT(df_tmc_moses_gb)[, stand_mean_ht := mean(tree_ht), by = .(stand, year)][])
#Calculating stand mean dbh per site per year:
df_tmc_moses_gb <- as.data.frame(setDT(df_tmc_moses_gb)[, stand_mean_dbh := mean(dbh), by = .(stand, year)][])
#Calculating stems number per site per year:
df_tmc_moses_gb <- as.data.frame(setDT(df_tmc_moses_gb)[, stem_no := length(tree_ht), by = .(stand, year)][])
#Calculating mean spacing per site per year:
df_tmc_moses_gb$plot_area_ha <- ifelse(df_tmc_moses_gb$stand == "Clocaenog~1~3", 1, 0.29) #add column to df with plot areas in ha
df_tmc_moses_gb$spacing <- sqrt((df_tmc_moses_gb$plot_area_ha * 10^4) / df_tmc_moses_gb$stem_no) #add column to df with mean spacing
#Calculating stand top height per site per year (mean height of 100 tallest trees per hectare)
df_tmc_moses_gb <- as.data.frame(setDT(df_tmc_moses_gb)[, ranked_tree_ht := sort(tree_ht, decreasing = TRUE), by = .(stand, year)][]) #add ranked height column to df with ranked trees by tree height, per site per yeat
df_tmc_moses_gb$st_y <- paste0(df_tmc_moses_gb$stand,"-", df_tmc_moses_gb$year) #create tag for standXyear combination
stand_top_ht <- as.numeric()
for (i in which(!duplicated(df_tmc_moses_gb$st_y))) { #go through
#df_tmc_moses_gb$stand_top_ht[i]
stand_top_ht[i] <- mean(df_tmc_moses_gb$ranked_tree_ht[i :(i + round(100*df_tmc_moses_gb$plot_area_ha[i]) -1)])
}
length(df_tmc_moses_gb)
stand_top_ht <- append(stand_top_ht, rep(NA, width(df_tmc_moses_gb)))
length(df_tmc_moses_gb$treeid)
length(stand_top_ht)
length(df_tmc_moses_gb$treeid) - length(stand_top_ht)
df_tmc_moses_gb$stand_top_ht <- stand_top_ht
df_tmc_moses_gb$stand_top_ht <- stand_top_ht
stand_top_ht <- append(stand_top_ht, rep(NA, (length(df_tmc_moses_gb$treeid) - length(stand_top_ht))))
df_tmc_moses_gb$stand_top_ht <- stand_top_ht
df_tmc_moses_gb$st_y <- NULL
df_tmc_moses_gb$ranked_tree_ht <- NULL
rm(stand_top_ht)
rm(i)
devtools::load_all()
library(tidyr)#this and Rcpp for "unnesting" the dataframe of lists output generated by the vectorised fg_rou
library(Rcpp)
fg_tmc_v <- Vectorize(fg_tmc)
stand_id <- as.character(df_tmc_moses_gb$stand)
tree_id <- as.character(df_tmc_moses_gb$treeid)
date <- as.Date(df_tmc_moses_gb$date)
tree_ht <- df_tmc_moses_gb$tree_height
tree_ht <- df_tmc_moses_gb$tree_ht
dbh <- df_tmc_moses_gb$dbh
spacing_current <- df_tmc_moses_gb$spacing
stand_mean_ht <- df_tmc_moses_gb$stand_mean_ht
stand_top_ht <- df_tmc_moses_gb$stand_top_ht
stand_mean_dbh <- df_tmc_moses_gb$stand_mean_dbh
cr_depth <- df_tmc_moses_gb$cr_depth
#Calculating mean crown depth per site per year:
df_tmc_moses_gb <- as.data.frame(setDT(df_tmc_moses_gb)[, stand_cr_depth := mean(cr_depth), by = .(stand, year)][])
stand_cr_depth <- df_tmc_moses_gb$stand_cr_depth
gap_size <- 0
out_tmc_moses_gb <- as.data.frame(t(fg_tmc_v(stand_id = stand_id, tree_id = tree_id, date = date, species = species, tree_ht = tree_ht, dbh = dbh,
spacing_current = spacing_current, predominant_species = species, stand_mean_ht = stand_mean_ht,
stand_mean_dbh = stand_mean_dbh, stand_top_ht = stand_top_ht, full_output = 1, cr_depth = cr_depth,
stand_cr_depth = stand_cr_depth, gap_size = gap_size)))
species <- as.character(df_tmc_moses_gb$species)
df_tmc_moses_gb$species[df_tmc_moses_gb$species == 'Sitka'] <- 'SS'
levels(df_tmc_moses_gb$species)
levels(df_tmc_moses_gb$species)[1] <- 'SS'
df_tmc_moses_gb$species
levels(df_tmc_moses_gb$species)
#moses-gb data####
df_tmc_moses_gb <- read.csv("F:/tom.locatelli/Software/ForestGALES-R scripts/mgb_for_fgr.csv", header = TRUE)
levels(df_tmc_moses_gb$species)[1] <- 'SS'
levels(df_tmc_moses_gb$species) <- 'SS'
df_tmc_moses_gb$date <- as.Date(paste0(df_tmc_moses_gb$year, '-01-01'))
#df_tmc_moses_gb$year <- NULL
df_tmc_moses_gb$cr_depth <- df_tmc_moses_gb$h - df_tmc_moses_gb$hlc
df_tmc_moses_gb$hlc <- NULL
names(df_tmc_moses_gb)[names(df_tmc_moses_gb) == 'h'] <- 'tree_ht'
#summary(df_tmc_moses_gb$stand)
#head(df_tmc_moses_gb$treeid[df_tmc_moses_gb$stand == "Kielder~1~10"])
df_tmc_moses_gb$year <- as.factor(df_tmc_moses_gb$year)
#Calculating stand mean height per site per year. Spacing and stand top height require knowledge of plot area:
library(data.table)
df_tmc_moses_gb <- as.data.frame(setDT(df_tmc_moses_gb)[, stand_mean_ht := mean(tree_ht), by = .(stand, year)][])
#Calculating stand mean dbh per site per year:
df_tmc_moses_gb <- as.data.frame(setDT(df_tmc_moses_gb)[, stand_mean_dbh := mean(dbh), by = .(stand, year)][])
#Calculating stems number per site per year:
df_tmc_moses_gb <- as.data.frame(setDT(df_tmc_moses_gb)[, stem_no := length(tree_ht), by = .(stand, year)][])
#Calculating mean spacing per site per year:
df_tmc_moses_gb$plot_area_ha <- ifelse(df_tmc_moses_gb$stand == "Clocaenog~1~3", 1, 0.29) #add column to df with plot areas in ha
df_tmc_moses_gb$spacing <- sqrt((df_tmc_moses_gb$plot_area_ha * 10^4) / df_tmc_moses_gb$stem_no) #add column to df with mean spacing
#Calculating mean crown depth per site per year:
df_tmc_moses_gb <- as.data.frame(setDT(df_tmc_moses_gb)[, stand_cr_depth := mean(cr_depth), by = .(stand, year)][])
#Calculating stand top height per site per year (mean height of 100 tallest trees per hectare)
df_tmc_moses_gb <- as.data.frame(setDT(df_tmc_moses_gb)[, ranked_tree_ht := sort(tree_ht, decreasing = TRUE), by = .(stand, year)][]) #add ranked height column to df with ranked trees by tree height, per site per yeat
df_tmc_moses_gb$st_y <- paste0(df_tmc_moses_gb$stand,"-", df_tmc_moses_gb$year) #create tag for standXyear combination
stand_top_ht <- as.numeric()
for (i in which(!duplicated(df_tmc_moses_gb$st_y))) { #go through
#df_tmc_moses_gb$stand_top_ht[i]
stand_top_ht[i] <- mean(df_tmc_moses_gb$ranked_tree_ht[i :(i + round(100*df_tmc_moses_gb$plot_area_ha[i]) -1)])
}
stand_top_ht <- append(stand_top_ht, rep(NA, (length(df_tmc_moses_gb$treeid) - length(stand_top_ht))))
df_tmc_moses_gb$stand_top_ht <- stand_top_ht
df_tmc_moses_gb$st_y <- NULL
df_tmc_moses_gb$ranked_tree_ht <- NULL
rm(stand_top_ht)
rm(i)
devtools::load_all()
library(tidyr)#this and Rcpp for "unnesting" the dataframe of lists output generated by the vectorised fg_rou
library(Rcpp)
fg_tmc_v <- Vectorize(fg_tmc)
stand_id <- as.character(df_tmc_moses_gb$stand)
tree_id <- as.character(df_tmc_moses_gb$treeid)
date <- as.Date(df_tmc_moses_gb$date)
species <- as.character(df_tmc_moses_gb$species)
tree_ht <- df_tmc_moses_gb$tree_ht
dbh <- df_tmc_moses_gb$dbh
spacing_current <- df_tmc_moses_gb$spacing
stand_mean_ht <- df_tmc_moses_gb$stand_mean_ht
stand_top_ht <- df_tmc_moses_gb$stand_top_ht
stand_mean_dbh <- df_tmc_moses_gb$stand_mean_dbh
cr_depth <- df_tmc_moses_gb$cr_depth
stand_cr_depth <- df_tmc_moses_gb$stand_cr_depth
gap_size <- 0
out_tmc_moses_gb <- as.data.frame(t(fg_tmc_v(stand_id = stand_id, tree_id = tree_id, date = date, species = species, tree_ht = tree_ht, dbh = dbh,
spacing_current = spacing_current, predominant_species = species, stand_mean_ht = stand_mean_ht,
stand_mean_dbh = stand_mean_dbh, stand_top_ht = stand_top_ht, full_output = 1, cr_depth = cr_depth,
stand_cr_depth = stand_cr_depth, gap_size = gap_size)))
out_tmc_moses_gb <- as.data.frame(t(fg_tmc_v(stand_id = stand_id, tree_id = tree_id, date = date, species = species, tree_ht = tree_ht, dbh = dbh,
spacing_current = spacing_current, predominant_species = species, stand_mean_ht = stand_mean_ht,
stand_mean_dbh = stand_mean_dbh, stand_top_ht = stand_top_ht, full_output = 1, cr_depth = cr_depth,
stand_cr_depth = stand_cr_depth, gap_size = gap_size)))
essentials
which(!duplicated(df_tmc_moses_gb$st_y))
df_tmc_moses_gb$st_y <- paste0(df_tmc_moses_gb$stand,"-", df_tmc_moses_gb$year) #create tag for standXyear combination
which(!duplicated(df_tmc_moses_gb$st_y))
#moses-gb data####
df_tmc_moses_gb <- read.csv("F:/tom.locatelli/Software/ForestGALES-R scripts/mgb_for_fgr.csv", header = TRUE)
levels(df_tmc_moses_gb$species) <- 'SS'
df_tmc_moses_gb$date <- as.Date(paste0(df_tmc_moses_gb$year, '-01-01'))
#df_tmc_moses_gb$year <- NULL
df_tmc_moses_gb$cr_depth <- df_tmc_moses_gb$h - df_tmc_moses_gb$hlc
df_tmc_moses_gb$hlc <- NULL
names(df_tmc_moses_gb)[names(df_tmc_moses_gb) == 'h'] <- 'tree_ht'
#summary(df_tmc_moses_gb$stand)
#head(df_tmc_moses_gb$treeid[df_tmc_moses_gb$stand == "Kielder~1~10"])
df_tmc_moses_gb$year <- as.factor(df_tmc_moses_gb$year)
#Calculating stand mean height per site per year. Spacing and stand top height require knowledge of plot area:
library(data.table)
df_tmc_moses_gb <- as.data.frame(setDT(df_tmc_moses_gb)[, stand_mean_ht := mean(tree_ht), by = .(stand, year)][])
#Calculating stand mean dbh per site per year:
df_tmc_moses_gb <- as.data.frame(setDT(df_tmc_moses_gb)[, stand_mean_dbh := mean(dbh), by = .(stand, year)][])
#Calculating stems number per site per year:
df_tmc_moses_gb <- as.data.frame(setDT(df_tmc_moses_gb)[, stem_no := length(tree_ht), by = .(stand, year)][])
#Calculating mean spacing per site per year:
df_tmc_moses_gb$plot_area_ha <- ifelse(df_tmc_moses_gb$stand == "Clocaenog~1~3", 1, 0.29) #add column to df with plot areas in ha
df_tmc_moses_gb$spacing <- sqrt((df_tmc_moses_gb$plot_area_ha * 10^4) / df_tmc_moses_gb$stem_no) #add column to df with mean spacing
#Calculating mean crown depth per site per year:
df_tmc_moses_gb <- as.data.frame(setDT(df_tmc_moses_gb)[, stand_cr_depth := mean(cr_depth), by = .(stand, year)][])
#Calculating stand top height per site per year (mean height of 100 tallest trees per hectare)
df_tmc_moses_gb <- as.data.frame(setDT(df_tmc_moses_gb)[, ranked_tree_ht := sort(tree_ht, decreasing = TRUE), by = .(stand, year)][]) #add ranked height column to df with ranked trees by tree height, per site per yeat
df_tmc_moses_gb$st_y <- paste0(df_tmc_moses_gb$stand,"-", df_tmc_moses_gb$year) #create tag for standXyear combination
stand_top_ht <- as.numeric()
changes_st_y <- which(!duplicated(df_tmc_moses_gb$st_y)) #where the unique values of st_y appear firs
?index
match_st_y <- match(!duplicated(df_tmc_moses_gb$st_y))
match_st_y <- match(changes_st_y)
match_st_y <- match(!duplicated(df_tmc_moses_gb$st_y), changes_st_y)
changes_st_y[1]
changes_st_y[2]
rm(match_st_y)
for (i in changes_st_y) { #go through
#df_tmc_moses_gb$stand_top_ht[i]
stand_top_ht[i] <- mean(df_tmc_moses_gb$ranked_tree_ht[i :(i + round(100*df_tmc_moses_gb$plot_area_ha[i]) -1)])
}
stand_top_ht[changes_st_y[1]:(changes_st_y[2]- 1)] <- stand_top_ht[changes_st_y[1]]
stand_top_ht[440:460]
length(changes_st_y)
for (i in changes_st_y) { #go through
#df_tmc_moses_gb$stand_top_ht[i]
stand_top_ht[i] <- mean(df_tmc_moses_gb$ranked_tree_ht[i :(i + round(100*df_tmc_moses_gb$plot_area_ha[i]) -1)])
}
stand_top_ht <- as.numeric()
for (i in changes_st_y) { #go through
#df_tmc_moses_gb$stand_top_ht[i]
stand_top_ht[i] <- mean(df_tmc_moses_gb$ranked_tree_ht[i :(i + round(100*df_tmc_moses_gb$plot_area_ha[i]) -1)])
}
#stand_top_ht <- append(stand_top_ht, rep(NA, (length(df_tmc_moses_gb$treeid) - length(stand_top_ht))))
for (j in 1:length(changes_st_y)){
stand_top_ht[changes_st_y[j]:(changes_st_y[j+1]- 1)] <- stand_top_ht[changes_st_y[j]]
}
changes_st_y[j]
changes_st_y[j+1]
length(changes_st_y)
changes_st_y
changes_st_y <- c(which(!duplicated(df_tmc_moses_gb$st_y)), length(df_tmc_moses_gb$treeid) #where the unique values of st_y appear first
)
changes_st_y
length(changes_st_y)
length(changes_st_y)-1)
length(changes_st_y)-1
stand_top_ht <- as.numeric()
changes_st_y <- c(which(!duplicated(df_tmc_moses_gb$st_y)), length(df_tmc_moses_gb$treeid)) #where the unique values of st_y appear first
for (i in changes_st_y) { #go through
#df_tmc_moses_gb$stand_top_ht[i]
stand_top_ht[i] <- mean(df_tmc_moses_gb$ranked_tree_ht[i :(i + round(100*df_tmc_moses_gb$plot_area_ha[i]) -1)])
}
#stand_top_ht <- append(stand_top_ht, rep(NA, (length(df_tmc_moses_gb$treeid) - length(stand_top_ht))))
for (j in 1:(length(changes_st_y)-1)){
stand_top_ht[changes_st_y[j]:(changes_st_y[j+1]- 1)] <- stand_top_ht[changes_st_y[j]]
}
tail(stand_top_ht)
stand_top_ht[length(stand_top_ht)]
stand_top_ht[length(stand_top_ht)-1]
stand_top_ht[length(stand_top_ht)] <- stand_top_ht[length(stand_top_ht)-1]
tail(stand_top_ht)
df_tmc_moses_gb$stand_top_ht <- stand_top_ht
changes_st_y <- c(which(!duplicated(df_tmc_moses_gb$st_y)), (length(df_tmc_moses_gb$treeid)+1)) #where the unique values of st_y appear first, plus the
changes_st_y
for (i in changes_st_y) { #go through
#df_tmc_moses_gb$stand_top_ht[i]
stand_top_ht[i] <- mean(df_tmc_moses_gb$ranked_tree_ht[i :(i + round(100*df_tmc_moses_gb$plot_area_ha[i]) -1)])
}
changes_st_y <- c(which(!duplicated(df_tmc_moses_gb$st_y)), length(df_tmc_moses_gb$treeid)) #where the unique values of st_y appear first, plus the
stand_top_ht <- as.numeric()
for (i in changes_st_y) { #go through
#df_tmc_moses_gb$stand_top_ht[i]
stand_top_ht[i] <- mean(df_tmc_moses_gb$ranked_tree_ht[i :(i + round(100*df_tmc_moses_gb$plot_area_ha[i]) -1)])
}
for (j in 1:(length(changes_st_y)-1)){
stand_top_ht[changes_st_y[j]:(changes_st_y[j+1]- 1)] <- stand_top_ht[changes_st_y[j]]
}
stand_top_ht[length(stand_top_ht)] <- stand_top_ht[length(stand_top_ht)-1]
df_tmc_moses_gb$stand_top_ht <- stand_top_ht
df_tmc_moses_gb$st_y <- NULL
df_tmc_moses_gb$ranked_tree_ht <- NULL
rm(stand_top_ht)
rm(changes_st_y)
rm(i)
rm(j)
devtools::load_all()
library(tidyr)#this and Rcpp for "unnesting" the dataframe of lists output generated by the vectorised fg_rou
library(Rcpp)
fg_tmc_v <- Vectorize(fg_tmc)
stand_id <- as.character(df_tmc_moses_gb$stand)
tree_id <- as.character(df_tmc_moses_gb$treeid)
date <- as.Date(df_tmc_moses_gb$date)
species <- as.character(df_tmc_moses_gb$species)
tree_ht <- df_tmc_moses_gb$tree_ht
dbh <- df_tmc_moses_gb$dbh
spacing_current <- df_tmc_moses_gb$spacing
stand_mean_ht <- df_tmc_moses_gb$stand_mean_ht
stand_top_ht <- df_tmc_moses_gb$stand_top_ht
stand_mean_dbh <- df_tmc_moses_gb$stand_mean_dbh
cr_depth <- df_tmc_moses_gb$cr_depth
stand_cr_depth <- df_tmc_moses_gb$stand_cr_depth
gap_size <- 0
out_tmc_moses_gb <- as.data.frame(t(fg_tmc_v(stand_id = stand_id, tree_id = tree_id, date = date, species = species, tree_ht = tree_ht, dbh = dbh,
spacing_current = spacing_current, predominant_species = species, stand_mean_ht = stand_mean_ht,
stand_mean_dbh = stand_mean_dbh, stand_top_ht = stand_top_ht, full_output = 1, cr_depth = cr_depth,
stand_cr_depth = stand_cr_depth, gap_size = gap_size)))
out_tmc_moses_gb <- as.data.frame(t(fg_tmc_v(stand_id = stand_id, tree_id = tree_id, date = date, species = species, tree_ht = tree_ht, dbh = dbh,
spacing_current = spacing_current, predominant_species = species, stand_mean_ht = stand_mean_ht,
stand_mean_dbh = stand_mean_dbh, stand_top_ht = stand_top_ht, full_output = 1, cr_depth = cr_depth,
stand_cr_depth = stand_cr_depth, gap_size = gap_size)))
dlf_fun(8382.10492332494, 22.31, 12.95, 2.42, 0.160042930811819, 13.21, 5.9e+09, 2.5, 850, 0, 150)
dlf_fun(8382.10492332494, 22.31, 12.95, 2.42, 0.160042930811819, 14.21, 5.9e+09, 2.5, 850, 0, 150)
22.31/13.21
22.31/14.21
22.31/14
22.31/1.6
dlf_fun(8382.10492332494, 22.31, 12.95, 2.42, 0.160042930811819, 13.94375, 5.9e+09, 2.5, 850, 0, 150)
dlf_fun(8382.10492332494, 22.31, 12.95, 2.42, 0.160042930811819, 13.22, 5.9e+09, 2.5, 850, 0, 150)
dlf_fun(8382.10492332494, 22.31, 12.95, 2.42, 0.160042930811819, 13.21, 5.9e+09, 2.5, 850, 0, 150)
dlf_fun(8382.10492332494, 22.31, 12.95, 2.42, 0.160042930811819, 13.22, 5.9e+09, 2.5, 850, 0, 150)
dlf_fun(8382.10492332494, 22.31, 12.95, 2.42, 0.160042930811819, 13.23, 5.9e+09, 2.5, 850, 0, 150)
dlf_fun(8382.10492332494, 22.31, 12.95, 2.42, 0.160042930811819, 13.24, 5.9e+09, 2.5, 850, 0, 150)
dlf_fun(8382.10492332494, 22.31, 12.95, 2.42, 0.160042930811819, 13.25, 5.9e+09, 2.5, 850, 0, 150)
dlf_fun(8382.10492332494, 22.31, 12.95, 2.42, 0.160042930811819, 13.26, 5.9e+09, 2.5, 850, 0, 150)
dlf_fun(8382.10492332494, 22.31, 12.95, 2.42, 0.160042930811819, 13.27, 5.9e+09, 2.5, 850, 0, 150)
dlf_fun(8382.10492332494, 22.31, 12.95, 2.42, 0.160042930811819, 13.28, 5.9e+09, 2.5, 850, 0, 150)
dlf_fun(8382.10492332494, 22.31, 12.95, 2.42, 0.160042930811819, 13.30, 5.9e+09, 2.5, 850, 0, 150)
dlf_fun(8382.10492332494, 22.31, 12.95, 2.42, 0.160042930811819, 13.301, 5.9e+09, 2.5, 850, 0, 150)
dlf_fun(8382.10492332494, 22.31, 12.95, 2.42, 0.160042930811819, 13.5, 5.9e+09, 2.5, 850, 0, 150)
dlf_fun(8382.10492332494, 22.31, 12.95, 2.42, 0.160042930811819, 13.9, 5.9e+09, 2.5, 850, 0, 150)
dlf_fun(8382.10492332494, 22.31, 12.95, 2.42, 0.160042930811819, 14, 5.9e+09, 2.5, 850, 0, 150)
dlf_fun(8382.10492332494, 22.31, 12.95, 2.42, 0.160042930811819, 15, 5.9e+09, 2.5, 850, 0, 150)
dlf_fun(8382.10492332494, 22.31, 12.95, 2.42, 0.160042930811819, 16, 5.9e+09, 2.5, 850, 0, 150)
dlf_fun(8382.10492332494, 22.31, 12.95, 2.42, 0.160042930811819, 17, 5.9e+09, 2.5, 850, 0, 150)
dlf_fun(8382.10492332494, 22.31, 12.95, 2.42, 0.160042930811819, 18, 5.9e+09, 2.5, 850, 0, 150)
dlf_fun(8382.10492332494, 22.31, 12.95, 2.42, 0.160042930811819, 19, 5.9e+09, 2.5, 850, 0, 150)
dlf_fun(8382.10492332494, 22.31, 12.95, 2.42, 0.160042930811819, 20, 5.9e+09, 2.5, 850, 0, 150)
dlf_fun(8382.10492332494, 22.31, 12.95, 2.42, 0.160042930811819, 30, 5.9e+09, 2.5, 850, 0, 150)
dlf_fun(8382.10492332494, 22.31, 12.95, 2.42, 0.160042930811819, 40, 5.9e+09, 2.5, 850, 0, 150)
devtools::load_all()
fg_tmc_v <- Vectorize(fg_tmc)
out_tmc_moses_gb <- as.data.frame(t(fg_tmc_v(stand_id = stand_id, tree_id = tree_id, date = date, species = species, tree_ht = tree_ht, dbh = dbh,
spacing_current = spacing_current, predominant_species = species, stand_mean_ht = stand_mean_ht,
stand_mean_dbh = stand_mean_dbh, stand_top_ht = stand_top_ht, full_output = 1, cr_depth = cr_depth,
stand_cr_depth = stand_cr_depth, gap_size = gap_size)))
devtools::load_all()
fg_tmc_v <- Vectorize(fg_tmc)
out_tmc_moses_gb <- as.data.frame(t(fg_tmc_v(stand_id = stand_id, tree_id = tree_id, date = date, species = species, tree_ht = tree_ht, dbh = dbh,
spacing_current = spacing_current, predominant_species = species, stand_mean_ht = stand_mean_ht,
stand_mean_dbh = stand_mean_dbh, stand_top_ht = stand_top_ht, full_output = 1, cr_depth = cr_depth,
stand_cr_depth = stand_cr_depth, gap_size = gap_size)))
tidy_out <- unnest(out_tmc_moses_gb)
write.csv(tidy_out, file = "F:/tom.locatelli/Software/RStudio/fgr/testing/out_tmc_moses_gb.csv")
rm(tidy_out)
df <- df_tmc_moses_gb
df$year <- NULL
df_tmc_moses_gb$year <- NULL
devtools::use_data(df_tmc_moses_gb, pkg = ".", overwrite = TRUE)
tidy_out <- unnest(out_tmc_moses_gb)
which(tidy_out$dlf_calc < 0)
length(which(tidy_out$dlf_calc < 0))
length(which(tidy_out$dlf_calc < 1))
bads <- tidy_out[which(tidy_out$dlf_calc < 1)]
bads <- tidy_out[which(tidy_out$dlf_calc < 1), ]
summary(bads$dlf_calc)
summary(bads$dlf_used)
bads <- df_tmc_moses_gb[which(tidy_out$dlf_calc < 1), ]
summary(bads$tree_ht)
summary(bads$dbh)
summary(bads$tree_ht / bads$dbh)
bads_plus <- df_tmc_moses_gb[which(tidy_out$dlf_calc > 2.5), ]
summary(bads_plus)
bads_plus <- tidy_out[which(tidy_out$dlf_calc > 2.5), ]
summary(bads_plus$dlf_calc)
which(bads_plus$dlf_calc > 100)
which(bads_plus$dlf_calc > 1000)
which(bads_plus$dlf_calc > 10000)
bads_plus[3180]
bads_plus[3180,]
summary(bads_plus$tree_ht / bads_plus$dbh)
summary(bads$tree_ht / bads$dbh)
df_tmc_moses_gb[which((bads_plus$tree_ht / bads_plus$dbh) == 1.106)]
which((bads_plus$tree_ht / bads_plus$dbh) == 1.106)
df_tmc_moses_gb[which((bads_plus$tree_ht / bads_plus$dbh) == 1.106),]
summary(bads_plus$tree_ht / bads_plus$dbh)
which((bads_plus$tree_ht / bads_plus$dbh) == 1.106)
which((bads_plus$tree_ht / bads_plus$dbh) < 1.108)
df_tmc_moses_gb[which((bads_plus$tree_ht / bads_plus$dbh) < 1.108),]
df_tmc_moses_gb[which((bads_plus$tree_ht / bads_plus$dbh) < 1.107),]
summary(bads$tree_ht / bads$dbh)
bads[which((bads$tree_ht / bads$dbh) < 1.107),]
which((bads$tree_ht / bads$dbh) < 1.107)
bads_plus[which((bads_plus$tree_ht / bads_plus$dbh) < 1.107),]
summary(bads$tree_ht / bads$dbh)
bads[which((bads$tree_ht / bads$dbh) < 1.410),]
bads_plus[which((bads_plus$tree_ht / bads_plus$dbh) > 2.323),]
bads_plus[which((bads_plus$tree_ht / bads_plus$dbh) > 2.3),]
summary(bads_plus$tree_ht / bads_plus$dbh)
bads_plus[which((bads_plus$tree_ht / bads_plus$dbh) < 1.107),]
summary(bads$tree_ht / bads$dbh)
bads_plus[which((bads$tree_ht / bads$dbh) < 2.323),]
bads_plus[which((bads$tree_ht / bads$dbh) > 2.323),]
summary(bads$tree_ht / bads$dbh)
bads_plus[which((bads$tree_ht / bads$dbh) > 2.3),]
bads_plus[which((bads$tree_ht / bads$dbh) > 2.32),]
bads[which((bads$tree_ht / bads$dbh) > 2.32),]
length(bads)
nrow(bads)
nrow(bads) + nrow(bads_plus)
nrow(df_tmc_moses_gb) / (nrow(bads) + nrow(bads_plus))
nrow(df_tmc_moses_gb) - (nrow(bads) + nrow(bads_plus))
(nrow(df_tmc_moses_gb) - (nrow(bads) + nrow(bads_plus))) / nrow(df_tmc_moses_gb)
wrongs <- tidy_out[which(tidy_out$dlf_calc / tidy_out$lf_used != 1)]
wrongs <- tidy_out[which(tidy_out$dlf_calc / tidy_out$lf_used != 1),]
(nrow(df_tmc_moses_gb) - (nrow(wrongs)) / nrow(df_tmc_moses_gb)
(nrow(df_tmc_moses_gb) - nrow(wrongs)) / nrow(df_tmc_moses_gb)
write.csv(df_tmc_moses_gb, file = "F:/tom.locatelli/Software/RStudio/fgr/testing/df_tmc_moses_gb.csv")
rm(bads)
rm(bads_plus)
rm(df)
rm(wrongs)
rm(tidy_out)
rm(out_tmc_moses_gb)
fgr_constants
devtools::load_all()
fg_tmc_v <- Vectorize(fg_tmc)
fg_tmc_v <- Vectorize(fg_tmc)
x <- df_tmc_moses_gb$x
y <- df_tmc_moses_gb$y
start_time <- Sys.time()
out_tmc_moses_gb <- as.data.frame(t(fg_tmc_v(stand_id = stand_id, tree_id = tree_id, date = date, species = species, tree_ht = tree_ht, dbh = dbh,
spacing_current = spacing_current, predominant_species = species, stand_mean_ht = stand_mean_ht,
stand_mean_dbh = stand_mean_dbh, stand_top_ht = stand_top_ht, full_output = 1, cr_depth = cr_depth,
stand_cr_depth = stand_cr_depth, gap_size = gap_size, x = x, y = y)))
fgr_constants
devtools::load_all()
library(tidyr)#this and Rcpp for "unnesting" the dataframe of lists output generated by the vectorised fg_rou
library(Rcpp)
fg_tmc_v <- Vectorize(fg_tmc)
start_time <- Sys.time()
out_tmc_moses_gb <- as.data.frame(t(fg_tmc_v(stand_id = stand_id, tree_id = tree_id, date = date, species = species, tree_ht = tree_ht, dbh = dbh,
spacing_current = spacing_current, predominant_species = species, stand_mean_ht = stand_mean_ht,
stand_mean_dbh = stand_mean_dbh, stand_top_ht = stand_top_ht, full_output = 1, cr_depth = cr_depth,
stand_cr_depth = stand_cr_depth, gap_size = gap_size, x = x, y = y)))
model_end_time <- Sys.time()
tidy_out <- unnest(out_tmc_moses_gb)
tidy_time <- Sys.time()
write.csv(tidy_out, file = "F:/tom.locatelli/Software/RStudio/fgr/testing/out_tmc_moses_gb.csv")
write.time <- Sys.time()
print("runs time:")
model_end_time - start_time
print("tidying time:")
tidy_time - model_end_time
print("time until tyding:")
tidy_time - start_time
print("total.time:")
write.time - start_time
fgr_constants$dlf
devtools::load_all()
fg_tmc_v <- Vectorize(fg_tmc)
start_time <- Sys.time()
out_tmc_moses_gb <- as.data.frame(t(fg_tmc_v(stand_id = stand_id, tree_id = tree_id, date = date, species = species, tree_ht = tree_ht, dbh = dbh,
spacing_current = spacing_current, predominant_species = species, stand_mean_ht = stand_mean_ht,
stand_mean_dbh = stand_mean_dbh, stand_top_ht = stand_top_ht, full_output = 1, cr_depth = cr_depth,
stand_cr_depth = stand_cr_depth, gap_size = gap_size, x = x, y = y)))
model_end_time <- Sys.time()
tidy_out <- unnest(out_tmc_moses_gb)
tidy_time <- Sys.time()
write.csv(tidy_out, file = "F:/tom.locatelli/Software/RStudio/fgr/testing/out_tmc_moses_gb.csv")
write.time <- Sys.time()
print("runs time:")
model_end_time - start_time
print("tidying time:")
tidy_time - model_end_time
print("time until tyding:")
tidy_time - start_time
print("total.time:")
write.time - start_time
write.csv(df_tmc_moses_gb, file = "F:/tom.locatelli/Software/ForestGALES-R Scripts/df_tmc_moses_gb.csv")
devtools::use_data(df_tmc_moses_gb, pkg = ".", overwrite = TRUE)
\begin{align}
u(h)_{crit\_break} = \frac{1}{D}\sqrt{\frac{\pi \cdot MOR \cdot dbh^3 \cdot f_{knot}}{32 \rho G d DLF}} \cdot \gamma
\end{align}
getwd()
#build####
devtools::build(pkg = ".", path = "F:/tom.locatelli/Software/RStudio/fgr/builds", binary = TRUE, vignettes = TRUE)
#build####
devtools::build(pkg = ".", path = "F:/tom.locatelli/Software/RStudio/fgr/builds", binary = TRUE, vignettes = TRUE)
#build####
devtools::build(pkg = ".", path = "F:/tom.locatelli/Software/RStudio/fgr/builds", binary = TRUE, vignettes = TRUE)
#build####
devtools::build(pkg = ".", path = "F:/tom.locatelli/Software/RStudio/fgr/builds", binary = TRUE, vignettes = TRUE)
#data####
species_parameters <- read.csv("F:/tom.locatelli/Software/ForestGALES-R scripts/species_parameters.csv", header = TRUE, row.names = 1)
devtools::use_data(species_parameters, pkg = ".", internal = TRUE, overwrite = TRUE)
#build####
devtools::build(pkg = ".", path = "F:/tom.locatelli/Software/RStudio/fgr/builds", binary = TRUE, vignettes = TRUE)
#data####
species_parameters <- read.csv("C:/Program Files/RStudio/fgr/ForestGALES-R scripts/species_parameters.csv", header = TRUE, row.names = 1)
fgr_constants <- read.csv("C:/Program Files/RStudio/fgr/ForestGALES-R scripts/fgr_constants.csv", header = TRUE)
devtools::use_data(species_parameters, fgr_constants, pkg = ".", internal = TRUE, overwrite = TRUE)
rm(species_parameters)
rm(fgr_constants)
#build####
devtools::build(pkg = ".", path = "C:/Program Files/RStudio/fgr/builds", binary = TRUE, vignettes = TRUE)
#build####
devtools::build(pkg = ".", path = "C:/Program Files/RStudio/fgr/builds", binary = TRUE, vignettes = TRUE)
#build####
devtools::build(pkg = ".", path = "C:/Program Files/RStudio/fgr/builds", binary = TRUE, vignettes = TRUE)
?canopy_breadth_b
desi <- c(1, 5, NA)
sw <- 100
msw <- 80
default_warning <- ifelse(anyNA(desi), "defw", NA) #"Warning: some inputs were set to default values"
desi <- c(1, 5, 8)
default_warning <- ifelse(anyNA(desi), "defw", NA) #"Warning: some inputs were set to default values"
desi <- c(1, 5, NA)
default_warning <- ifelse(anyNA(desi), "defw", NA) #"Warning: some inputs were set to default values"
max_stem_weight_warning <- ifelse(sw > msw, "msw", NA)
fgr_warnings <- paste0(default_warning, "_", max_stem_weight_warning)
desi <- c(1, 5, 8)
default_warning <- ifelse(anyNA(desi), "defw", NA) #"Warning: some inputs were set to default values"
fgr_warnings <- paste0(default_warning, "_", max_stem_weight_warning)
msw <- 120
max_stem_weight_warning <- ifelse(sw > msw, "msw", NA)
fgr_warnings <- paste0(default_warning, "_", max_stem_weight_warning)
install.packages("roxygen2")
fgr_constants$cs
fgr::fgr_constants$cs
1/sqrt(fgr::fgr_constants$cs + fgr::fgr_constants$cr*0.3)
#data####
species_parameters <- read.csv("C:/Program Files/RStudio/fgr/ForestGALES-R scripts/species_parameters_SP_DF.csv", header = TRUE, row.names = 1)
fgr_constants <- read.csv("C:/Program Files/RStudio/fgr/ForestGALES-R scripts/fgr_constants.csv", header = TRUE)
devtools::use_data(species_parameters, fgr_constants, pkg = ".", internal = TRUE, overwrite = TRUE)
rm(species_parameters)
rm(fgr_constants)
?round
round(0.123, 1)
round(123.5, 0)
ceiling(123.5, 0)
ceiling(123.5)
floor(123.5)
trunc(123.5)
trunc(123.3)
trunc(123.6)
trunc(123.6)
trunc(123.4)
ceiling(123.4)
round(1.5, 1)
round(1.5)
round(2.5)
round(3.5)
.libPaths()
>>>>>>> 53fe1c19bd83483d1cee4de7bb8034f645edc47f
